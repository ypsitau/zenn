---
title: "pico-jxglib でファイルシステムを実装してシェルを強化する話 (自動補完機能つき)"
emoji: "👌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["組み込み", "raspberrypi", "pico", "raspberrypipico", "usb"]
published: false
---
**pico-jxglib** は、ワンボードマイコン Raspberry Pi Pico の Pico SDK プログラミングをサポートするライブラリです。

https://zenn.dev/ypsitau/articles/2025-01-24-jxglib-intro

今回は、ファイルシステムを実装して FAT と LittleFS をサポートします。これにより、Pico ボード上のフラッシュメモリをファイルシステムとして扱うことができ、SD カードや USB メモリなどのストレージデバイスを簡単に操作できるようになります。また、シェルもファイルシステムを利用できるように強化し、自動補完機能を追加します。

なお、この回では保存デバイスとしてフラッシュメモリを扱います。SD カードや USB メモリなどのストレージデバイスを扱うための方法は次回以降に説明します。

## ファイルシステムについて

組込み用途では、フラッシュメモリをファイルシステムとして扱うことがよくあります。そのためのライブラリとして FatFs や LittleFS などがあり、比較的容易に自作プログラムにファイルシステムを組み込めるのですが、ストレージデバイスのドライバを最初から作るのは少々面倒です。また、ファイルやディレクトリの作成や削除を行う手段が用意されていないため、プログラム内にハードコーディングしておく必要があります。

**pico-jxglib** では、これらのライブラリをラップして、Pico SDK のプログラムから簡単にファイルシステムを扱えるようにしています。さらに、シェルを強化してファイル操作用のコマンドを実装し 、一般的な OS のシェルのようにファイルシステムを操作できるようにしました。

**pico-jxglib** のファイルシステムは、以下の特徴を持っています。

- フォーマットとして FAT と LittleFS をサポートしています
- ストレージデバイスとして、Pico ボード上のフラッシュメモリ・SD カード・USB メモリを扱うことができます
- シェル上でファイルのコピーや削除、ディレクトリの作成や削除などの基本的なファイル操作が可能です
- シェルコマンドの出力をリダイレクトしてファイルに保存できます
- 自動補完機能を持ち、シェルコマンドの入力を補完できます

## 実際のプロジェクト

今回は Pico ボード上のフラッシュメモリをファイルシステムとして扱うので、Pico ボード以外にハードウェアの準備は必要ありません。


### 開発環境のセットアップ

Visual Studio Code や Git ツール、Pico SDK のセットアップが済んでいない方は[「Pico SDK ことはじめ」](https://zenn.dev/ypsitau/articles/2025-01-17-picosdk#%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83) をご覧ください。

GitHub から **pico-jxglib** をクローンします。

```bash
git clone https://github.com/ypsitau/pico-jxglib.git
cd pico-jxglib
git submodule update --init
```

:::message
**pico-jxglib** はほぼ毎日更新されています。すでにクローンしている場合は、`pico-jxglib` ディレクトリで以下のコマンドを実行して最新のものにしてください。

```bash
git pull
```

:::

### プロジェクトの作成

VSCode のコマンドパレットから `>Raspberry Pi Pico: New Pico Project` を実行し、以下の内容でプロジェクトを作成します。Pico SDK プロジェクト作成の詳細や、ビルド、ボードへの書き込み方法については[「Pico SDK ことはじめ」](https://zenn.dev/ypsitau/articles/2025-01-17-picosdk#%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90%E3%81%A8%E7%B7%A8%E9%9B%86) を参照ください。

- **Name** ... プロジェクト名を入力します。今回は例として `fs-test` を入力します
- **Board type** ... ボード種別を選択します
- **Location** ... プロジェクトディレクトリを作る一つ上のディレクトリを選択します
- **Stdio support** .. Stdio に接続するポート (UART または USB) を選択します
- **Code generation options** ... **`Generate C++ code` にチェックをつけます**

プロジェクトディレクトリと `pico-jxglib` のディレクトリ配置が以下のようになっていると想定します。

```text
+-[pico-jxglib]
+-[fs-test]
  +-CMakeLists.txt
  +-fs-test.cpp
  +- ...
```


以下、このプロジェクトをもとに `CMakeLists.txt` やソースファイルを編集してプログラムを作成していきます。

### Pico ボードのフラッシュメモリについて

Pico ボードのフラッシュメモリは以下のようなアドレス範囲を持っています。

- Pico ボード: 0x1000'0000 - 0x101f'ffff (2MB)
- Pico2 ボード: 0x1000'0000 - 0x103f'ffff (4MB)

プログラムは先頭の 0x1000'0000 から書き込まれるので、残りのフラッシュメモリをファイルシステムとして利用できます。プログラムが占有する範囲を確認するには以下の方法があります。

- **マップファイルを参照する**
  プロジェクト中の `build` ディレクトリ中に `project-name.elf.map` という名前のファイルが生成されるので、この中から `.flash_end` を検索します。このシンボルの値がプログラムが占有するフラッシュメモリの終端アドレスになります。

- **picotool　を使う**
  picotool を使って、ビルドした ELF ファイルの情報を表示します。以下のコマンドを実行します。

  ```bash
  picotool info build/project-name.elf
  ```

  `binary end` の値がプログラムが占有するフラッシュメモリの終端アドレスになります。

### FAT ファイルシステムの実装


`CMakeLists.txt` の最後に以下の行を追加します。`jxglib_FAT_Flash` ライブラリを追加し、`jxglib_configure_FAT()` を呼び出して FAT ファイルシステムの設定を行います。

```cmake
target_link_libraries(test-fs jxglib_FAT_Flash)
add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../pico-jxglib pico-jxglib)
jxglib_configure_FAT(fs-test FF_VOLUMES 1)
```

ソースファイルを以下のように編集します。`FAT::Flash` インスタンスを生成すると、Pico ボード上のフラッシュメモリを FAT ファイルシステムとして扱えるようになります。

```cpp:fs-test.cpp
#include <stdio.h>
#include "pico/stdlib.h"
#include "jxglib/FAT/Flash.h"

using namespace jxglib;

int main()
{
    ::stdio_init_all();
    FAT::Flash fat("C", 0x0004'0000); // 256kB
    for (;;) {
        // any job
        Tickable::Tick();
    }
}
```

### LittleFS ファイルシステムの実装

### 複数のファイルシステムの実装