---
title: "スタンドアローンでプロトコル解析もできる! 本当はスゴい la コマンドの話"
emoji: "📚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["raspberrypi", "pico", "raspberrypipico", "logicanalyzer", "protocoldecoder"]
published: false
---
[pico-jxgLABO](https://zenn.dev/ypsitau/articles/2025-08-01-labo-intro) は、USB ケーブル一本でマイコンボード RaspberryPi Pico の様々な機能を試すことができる実験プラットフォームです。

この記事では、pico-jxgLABO のロジックアナライザコマンド `la` の機能を紹介します。`la` コマンドはコンソールベースのツールで、PulseView と連携するときはバックエンドで黙々と動作するだけの存在です。でも、このコマンド単体でも波形表示ができますし、I2C や SPI、UART などのプロトコル解析もできるんです。本記事を通じて、`la` コマンドのスゴさを知っていただけれると嬉しいです。

PulseView との連携については以下の記事を参照ください。

▶️ [pico-jxgLABO × PulseView: プローブ接続いらずで気軽に使えるロジックアナライザを体験しよう!](https://zenn.dev/ypsit/articles/2025-09-01-labo-pulseview)

## pico-jxgLABO の書き込み

Pico ボードへの pico-jxgLABO の書き込みと基本的な使い方は[こちら](https://zenn.dev/ypsitau/articles/2025-08-01-labo-intro#pico-jxglabo-%E3%81%AE%E5%B0%8E%E5%85%A5%E6%96%B9%E6%B3%95)。特別なハードウェアは必要なく、Pico や Pico 2 ボードを USB ケーブルで PC に接続するだけで始められます。

この記事で説明する実験を行うには、バージョン `0.2.0` 以降の pico-jxgLABO が Pico ボードに書き込まれている必要があります。ターミナルソフトで `about-me` コマンドを実行すると pico-jxgLABO のバージョンを確認できます。

```text
L:/>about-me
Program Information
 name:              pico-jxgLABO
 version:           0.2.0
     :
     :
```

## `la` コマンドの機能

`la` コマンドの動作は大きく分けて二つあり、一つはデータサンプリング、もう一つは波形表示および解析です。データサンプリングで信号データをメモリにとりこみ、そのメモリ内容を参照して波形表示や解析を行うという流れになります。

### データサンプリング

#### サンプリングの開始と停止

`la` コマンドの `-p` (または `--pins`) オプションで測定する GPIO ピンを指定し、`enable` サブコマンドを実行することでサンプリングを開始します。

```text
L:/>la -p 2,3,4 enable
```

GPIO ピンはピン番号をカンマで区切って指定します。ハイフンを使って範囲指定をすることもできます。以下の表に例を示します。

|GPIO ピン指定 |内容                             |
|-------------|---------------------------------|
|`-p 0`       |GPIO0 を指定します                |
|`-p 2,3,8,9` |GPIO2,3,8,9 を指定します          |
|`-p 8-15`    |GPIO8 から GPIO15 までを指定します |
|`-p 2-4,8-13`|GPIO2 から GPIO4、GPIO8 から GPIO13 までを指定します|

このオプションで指定した GPIO ピンの情報は、`la` コマンドや PulseView での波形表示にも反映されます。

`la` コマンドは、データ格納用のバッファメモリを確保した後、PIO (Programmable Input/Output) と DMA (Direct Memory Access) に対してサンプリング処理を指示してすぐに終了します。実際の処理はこれら PIO と DMA が行うので、**CPU 負荷はほぼゼロ**です。

`la` コマンドで `disable` サブコマンドを実行するとサンプリングを停止し、PIO、DMA およびバッファメモリのリソースを解放します。

```text
L:/>la disable
```

サンプリングを最初からやり直す場合は `enable` サブコマンドを実行します。`disable` を明示的に実行する必要はありません。また、GPIO ピンなどの指定は前回の設定が引き継がれるので、変更がなければ `enable` だけ実行すれば大丈夫です。

```text
L:/>la enable
```

#### PulseView との連携

PulseView で `Start` ボタンを押すと、Pico ボード内で `la enable` コマンド相当の処理を実行します。測定する GPIO ピンの設定や他のサンプリングにかかわるオプションは、これよりも前に `la` コマンドで設定しておく必要があります。

サンプリングが始まると、pico-jxgLABO はバッファメモリの状態をポーリングし、サンプリングデータがあると PulseView に送信します。`Stop` ボタンを押すと、このサンプリングデータの送信を停止します。データ転送が終了してもバッファメモリの内容はそのままなので、`la` コマンドの `print` サブコマンドで波形データを表示したり、プロトコルデコードを行ったりできます。

#### サンプリングモードについて

pico-jxgLABO のロジックアナライザは、transitional モードでサンプリング処理を行います。transitional モードでは、信号が変化したときだけデータをサンプリングするので、メモリバッファを効率的に使用できます。また、信号の変化が速い(周波数が高い)場合でも、遅い(周波数が低い)場合でも、同じサンプリングレートでサンプリングできます。

#### 内部信号と外部信号の選択

`--target` オプションでサンプリング対象を指定できます。`internal` (デフォルト) を指定すると Pico 内部の信号を、`external` を指定すると GPIO ピンに入力された外部信号をサンプリングします。

- `--target:internal` Pico 内部の信号をサンプリングします
- `--target:external` GPIO ピンに入力された外部信号をサンプリングします

`--target` オプションはすべての GPIO ピンを一括で設定しますが、以下のオプションを使うことで GPIO ピン毎に設定を変更することができます。

- `--internal:PINS` 内部信号のサンプリングをする GPIO ピンを指定します
- `--external:PINS` 外部信号のサンプリングをする GPIO ピンを指定します
- `--inherited:PINS` `--target` オプションの設定を引き継ぐ GPIO ピンを指定します

測定対象が外部信号の場合、`la` を実行したときの状態表示で GPIO ピン番号の前にバッククォート (`) が付きます。以下に例を示します。

```text
L:/>la -p 2,3 --target:internal
disabled ---- 12.5MHz (samplers:1) pins:2,3 events:0/0 (heap-ratio:0.7)
L:/>la -p 2,3 --target:external
disabled ---- 12.5MHz (samplers:1) pins:`2,`3 events:0/0 (heap-ratio:0.7)
```

#### サンプリングレートの指定

pico-jxgLABO は PIO のステートマシンを使ってサンプリング処理を行います。このサンプリング処理を行うステートマシンのことを、ここではサンプラーと呼びます。

サンプラーが一つのデータのサンプリングをするのに必要なクロック数は 12 クロックです。つまり、クロック周波数 150MHz の Pico2 の場合、150MHz ÷ 12 = 12.5MHz のサンプリングが可能です。Pico (クロック周波数 125MHz) の場合は、125MHz ÷ 12 = 10.4MHz のサンプリングが可能になります。

ひとつの PIO ブロックには 4 個のステートマシン (サンプラー) が搭載されています。これらを開始時刻をずらして並行動作させることで、サンプリングレートを上げることができます。動作させるサンプラーの数はオプション `--samplers` で指定します。以下に例を示します。

|コマンド　        |サンプリングレート                 |
|-----------------|---------------------------------|
|`--samplers:1`   |12.5MHz (Pico2), 10.4MHz (Pico)  |
|`--samplers:2`   |25.0MHz (Pico2), 20.8MHz (Pico)  |
|`--samplers:3`   |37.5MHz (Pico2), 31.2MHz (Pico)  |
|`--samplers:4`   |50.0MHz (Pico2), 41.7MHz (Pico)  |

サンプラーの数を増やすとサンプリングレートが上がりますが、サンプリングできるイベントの数が減ります。

#### 使用する PIO の指定

Pico2 は PIO0, PIO1, PIO2 の 3 ブロック、Pico は PIO0 と PIO1 の 2 ブロックを搭載しています。デフォルトでは、PIO2 (Pico2) または PIO1 (Pico) をロジックアナライザ用に使用しますが、`--pio` オプションで使用する PIO ブロックを指定できます。以下に例を示します。

- `--pio:0` PIO0 を使用します
- `--pio:1` PIO1 を使用します
- `--pio:2` PIO2 を使用します

#### メモリバッファのサイズ指定

`--help-ratio` オプションでメモリバッファのサイズを指定できます。デフォルトは `0.7` で、使用可能なヒープ領域の 70% をバッファとして使用します。他の用途でヒープ領域が足りない場合は、この数値を小さくしてください。

### 波形表示

`la` コマンドの `print` サブコマンドで、サンプリングした波形データをテキストベースで表示することができます。ここでは例として I2C インターフェースの信号をキャプチャします。

まず、GPIO2 (I2C SDA) と GPIO3 (I2C SCL) を測定対象にしてキャプチャを開始します。

```text
L:/>la -p 2,3 enable
enabled pio:2 12.5MHz (samplers:1) pins:2,3 events:1/88620 (heap-ratio:0.7)
```

次に、`i2c1` コマンドを使って I2C プロトコルの信号を出力します。オプション `-p` で使用する SDA, SCL ピンを指定します。`scan` サブコマンドは、アドレス 0 から 127 に対して Read リクエストを送信し、応答があったアドレスを表示します。

```text
L:/>i2c1 -p 2,3 scan
Bus Scan on I2C1
   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
00 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
10 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
50 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
70 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
```

これで I2C の信号が生成されました。キャプチャがされているか、`la` コマンドを実行してロジックアナライザの状態を確認します。

```text
L:/>la
enabled pio:2 12.5MHz (samplers:1) pins:2,3 events:3459/88620 (heap-ratio:0.7)
```

イベントの数が増えて、信号のキャプチャがされていることがわかります。`la print` コマンドを使って、キャプチャした信号を表示します。

```text
L:/>la print
 Time [usec] P2  P3
             │   │
             :   :
        0.00 └─┐ │
        1.28   │ └─┐
      776.00 ┌─┘   │
      780.40 │   ┌─┘
      786.72 │   └─┐
      791.20 │   ┌─┘
      797.52 │   └─┐
      801.92 │   ┌─┘
      808.32 │   └─┐
      812.72 │   ┌─┘
      819.04 │   └─┐
      823.44 │   ┌─┘
      829.84 │   └─┐
      834.24 │   ┌─┘
      840.56 │   └─┐
      845.04 │   ┌─┘
      851.36 │   └─┐
      855.76 │   ┌─┘
      856.40 └─┐ │
      862.08   │ └─┐
      866.56   │ ┌─┘
      872.88   │ └─┐
      877.28   │ ┌─┘
      877.60 ┌─┘ │
      883.60 │   └─┐
      888.80 └─┐   │
      917.84 ┌─┘   │
         :
         :
```

表示分解能 (1 行あたりに表示する時間間隔) は、デフォルトで 1000usec (1msec) です。上の例だとエッジの間隔が 5usec 程度ですから、それよりも短くしないと正しい表示ができません。そこで、オプション `--reso` を使って、表示分解能を 4usec に設定して波形表示をします。

```text
L:/>la print --reso:4
 Time [usec] P2  P3
             │   │
             :   :
        0.00 └─┐ │
        1.28   │ └─┐
               :   :
      776.00 ┌─┘   │
             │     │
      780.40 │   ┌─┘
             │   │
      786.72 │   └─┐
             │     │
      791.20 │   ┌─┘
             │   │
      797.52 │   └─┐
             │     │
      801.92 │   ┌─┘
             │   │
      808.32 │   └─┐
             │     │
      812.72 │   ┌─┘
             │   │
      819.04 │   └─┐
             │     │
      823.44 │   ┌─┘
             │   │
      829.84 │   └─┐
             │     │
      834.24 │   ┌─┘
             │   │
      840.56 │   └─┐
             │     │
      845.04 │   ┌─┘
             │   │
      851.36 │   └─┐
             │     │
      855.76 │   ┌─┘
      856.40 └─┐ │
               │ │
      862.08   │ └─┐
               │   │
      866.56   │ ┌─┘
               │ │
      872.88   │ └─┐
               │   │
      877.28   │ ┌─┘
      877.60 ┌─┘ │
             │   │
      883.60 │   └─┐
             │     │
      888.80 └─┐   │
               │   │
               │   │
               │   │
               │   │
               │   │
               │   │
               │   │
      917.84 ┌─┘   │
         :
         :
```

`la print` は、デフォルトでは最初の 80 イベントを表示します。`--part:tail` オプションを使うと、最後の 80 イベントを表示できます。表示するイベント数を変更するには、オプション `--events:N` (`N` はイベント数) を指定します。

`--part:all` オプションを使うと、すべてのイベントを表示できます。

```text
L:/>la print --part:all
 Time [usec] P2  P3
             │   │
             :   :
        0.00 └─┐ │
        1.28   │ └─┐
               :   :
      776.00 ┌─┘   │
             │     │
      780.40 │   ┌─┘
             │   │
      786.72 │   └─┐
             │     │
             :
             :
```

`Ctrl-C` キーを押すと、表示を中断できます。

リダイレクトを使うと、表示内容をファイルに保存できます。例えば、`i2c.log` というファイルに保存するには以下のようにします。

```text
L:/>la print --part:all > i2c.log
```

波形の表示には Unicode のマルチバイト文字を使用していますが、環境によっては文字化けすることがあります。その場合は、オプション `--style:ascii2` などを指定すると ASCII 文字だけで表示できます。

```text
L:/>la print --style:ascii2
 Time [usec] P2  P3
             |   |
             :   :
        0.00 `-, |
        1.28   | `-,
               :   :
      776.00 ,-'   |
             |     |
      780.40 |   ,-'
             |   |
      786.72 |   `-,
             |     |
```

`--style` オプションには、文字種や波形の大きさが異なる以下のスタイルを指定できます。デフォルトは `unicode2` です。

- `unicode1`, `unicode2`, `unicode3`, `unicode4` ... Unicode マルチバイト文字を使用
- `ascii1`, `ascii2`, `ascii3`, `ascii4` ... ASCII 文字を使用

### プロトコルデコード

サブコマンド `dec` を使うと、I2C や SPI、UART などのプロトコルデコードができます。`dec` サブコマンドの書式は以下の通りです。

`dec:DECODER {SUB-COMMANDS...}`

`DECODER` は `i2c`, `spi`, `uart` などのプロトコルデコーダ名を指定します。ブレースで囲まれた `SUB-COMMANDS` にはデコーダ毎に異なるサブコマンドを指定します。

#### I2C プロトコルデコード

I2C プロトコルをデコードするには、`dec` サブコマンドのプロトコル名に `i2c` を指定し、以下のサブコマンドを指定します。

|サブコマンド     |機能                              |
|----------------|---------------------------------|
|`sda:PIN`       |SDA ピンを指定                     |
|`scl:PIN`       |SCL ピンを指定                     |

`i2c1 scan` コマンド使ってアドレス 0 から 127 に対して Read リクエストを送信したときの信号をキャプチャし、`la dec:i2c` コマンドでデコードしてみます。

```text
L:/>la -p 2,3 enable
L:/>i2c1 -p 2,3 scan
L:/>la dec:i2c {sda:2 scl:3} print --reso:4
 Time [usec] P2  P3
             │   │
             :   :
        0.00 └─┐ │
        1.28   │ └─┐
               :   :
      776.00 ┌─┘   │ Start
             │     │
      780.40 │   ┌─┘
             │   │
      786.72 │   └─┐ 0 msb
             │     │
      791.20 │   ┌─┘
             │   │
      797.52 │   └─┐ 0
             │     │
      801.92 │   ┌─┘
             │   │
      808.32 │   └─┐ 0
             │     │
      812.72 │   ┌─┘
             │   │
      819.04 │   └─┐ 0 Addr:0x00:R
             │     │
      823.44 │   ┌─┘
             │   │
      829.84 │   └─┐ 0
             │     │
      834.24 │   ┌─┘
             │   │
      840.56 │   └─┐ 0
             │     │
      845.04 │   ┌─┘
             │   │
      851.36 │   └─┐ 0 lsb
             │     │
      855.76 │   ┌─┘
      856.40 └─┐ │
               │ │
      862.08   │ └─┐ Read
               │   │
      866.56   │ ┌─┘
               │ │
      872.88   │ └─┐ Nack
               │   │
      877.28   │ ┌─┘
      877.60 ┌─┘ │
             │   │
      883.60 │   └─┐ 0 msb
             │     │
      888.80 └─┐   │ Stop
               │   │
               │   │
               │   │
               │   │
               │   │
               │   │
               │   │
      917.84 ┌─┘   │ Start
```

#### SPI プロトコルデコード

SPI プロトコルをデコードするには、`dec` サブコマンドのプロトコル名に `spi` を指定し、以下のサブコマンドを指定します。

|サブコマンド     |機能              |
|----------------|-----------------|
|`mode:MODE`     |SPI モードを指定 (0-3) |
|`mosi:PIN`     |MOSI ピンを指定   |
|`miso:PIN`     |MISO ピンを指定   |
|`sck:PIN`      |SCK ピンを指定    |

`mosi` と `miso` はどちらか一方または両方を必ず指定します。

`spi0 write` コマンド使って SPI の MOSI に 0 から 255 までのデータを送信したときの信号をキャプチャし、`la dec:spi` コマンドでデコードしてみます。

```text
L:/>la -p 2,3 enable
L:/>spi0 -p 2,3 write:0-255
L:/>la dec:spi {mode:0 sck:2 mosi:3} print --reso:0.4
 Time [usec] P2  P3
               │   │
               :   :
        0.00 ┌─┘   │
             :     :
      252.16 │   ┌─┘
             │   │
             │   │
      253.12 └─┐ │   0 msb
               │ │
      253.60 ┌─┘ │
             │   │
      254.16 └─┐ │   0
               │ │
      254.64 ┌─┘ │
             │   │
      255.12 └─┐ │   0
               │ │
      255.60 ┌─┘ │
             │   │
      256.16 └─┐ │   0 MOSI:0x00
               │ │
      256.64 ┌─┘ │
             │   │
      257.12 └─┐ │   0
               │ │
      257.60 ┌─┘ │
             │   │
      258.16 └─┐ │   0
               │ │
      258.64 ┌─┘ │
             │   │
      259.12 └─┐ │   0
               │ │
      259.60 ┌─┘ │
             │   │
      260.16 └─┐ │   0 lsb
               │ │
      260.64 ┌─┘ │
             │   │
             │   │
             │   │
             │   │
      262.64 └─┐ │   0 msb
               │ │
      263.12 ┌─┘ │
             │   │
      263.60 └─┐ │   0
               │ │
      264.16 ┌─┘ │
             │   │
      264.64 └─┐ │   0
               │ │
      265.12 ┌─┘ │
             │   │
      265.60 └─┐ │   0 MOSI:0x01
           :
           :
```

#### UART プロトコルデコード

UART プロトコルをデコードするには、`dec` サブコマンドのプロトコル名に `uart` を指定し、以下のサブコマンドを指定します。

|サブコマンド     |機能                              |
|----------------|---------------------------------|
|`tx:PIN`       |TX ピンを指定                     |
|`rx:PIN`       |RX ピンを指定                     |
|`baudrate:RATE`|ボーレートを指定。デフォルトは 115200                   |
|`frame:NPS`|フレームフォーマットを指定。`N` はデータビット長 (5, 6, 7, 8, 9)、P はパリティ (N:none, E：even, O:odd)、 S はストップビット長 (1, 2)。デフォルトは `8n1` (8bit, none, 1bit stop) |

`baudrate` と `frame` は省略可能です。`tx` と `rx` はどちらか一方または両方を必ず指定します。

`uart1 write` コマンド使って UART の TX に 0 から 255 までのデータを送信したときの信号をキャプチャし、`la dec:uart` コマンドでデコードしてみます。

```text
L:/>la -p 4 enable
L:/>uart1 -p 4 write:0-255
L:/>la dec:uart {tx:4} print --reso:4
 Time [usec] P4
             │
             :
        0.00 └─┐
               :
      303.68 ┌─┘ TX:0x00
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
      381.76 └─┐
               │
               │
      390.48 ┌─┘ TX:0x01
             │
             │
      399.12 └─┐
               │
               │
      407.84 ┌─┘
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
             │
      468.56 └─┐
               │
          :
          :
```

## まとめ

本記事では `la` コマンドの詳細と、プロトコルデコードの方法について説明しました。コンソールベースだからこそ得られる簡便性と柔軟性があり、Pico ボード単体で手軽にロジックアナライザとして使用できます。GUI ベースの PulseView などのツールと使い分けることで、より効果的にロジックアナライザを活用できるでしょう。
