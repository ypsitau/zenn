---
title: "pico-jxglib で pico ボードにシェルを実装する話"
emoji: "😺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["組み込み", "raspberrypi", "pico", "raspberrypipico", "usb"]
published: true
---
**pico-jxglib** は、ワンボードマイコン Raspberry Pi Pico の Pico SDK プログラミングをサポートするライブラリです。

https://zenn.dev/ypsitau/articles/2025-01-24-jxglib-intro

今回は、以前に上げた記事[「pico-jxglib とコマンドライン編集機能の話」](https://zenn.dev/ypsitau/articles/2025-04-06-cmdline-editor)で紹介した Terminal のコマンド入力機能を使って、pico ボードにシェル機能を実装します。

## シェル機能について

組込みボードの開発では、プログラムコード編集・ボード書き込み・実行というサイクルを続けるので、プログラムの挙動を変えたい場合はコードを直接変更するのが一番てっとり早い方法です。でも、変更するパラメータなどが多くなったり、結果を見て少しずつ挙動を変更したい場合などは、この手順が煩わしくなってきます。そういった場合、ボード自身がコマンドを受け付けられるようなシェルが走っていると、試行錯誤や実験がスムースになります。特に、FatFS や LittleFS などを使ってファイルシステムを扱うようなアプリを作ると、ディレクトリの内容を確認したりするのにシェルは重宝しそうです。

## 実際のプロジェクト

### 開発環境のセットアップ

Visual Studio Code や Git ツール、Pico SDK のセットアップが済んでいない方は[「Pico SDK ことはじめ」](https://zenn.dev/ypsitau/articles/2025-01-17-picosdk#%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83) をご覧ください。

**pico-jxglib** は GitHub からレポジトリをクローンすることで入手できます。

```bash
git clone https://github.com/ypsitau/pico-jxglib.git
cd pico-jxglib
git submodule update --init
```

:::message
**pico-jxglib** はほぼ毎日更新されています。すでにクローンしている場合は、`pico-jxglib` ディレクトリで以下のコマンドを実行して最新のものにしてください。

```bash
git pull
```

:::

### プロジェクトの作成

VSCode のコマンドパレットから `>Raspberry Pi Pico: New Pico Project` を実行し、以下の内容でプロジェクトを作成します。Pico SDK プロジェクト作成の詳細や、ビルド、ボードへの書き込み方法については[「Pico SDK ことはじめ」](https://zenn.dev/ypsitau/articles/2025-01-17-picosdk#%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90%E3%81%A8%E7%B7%A8%E9%9B%86) を参照ください。

- **Name** ... プロジェクト名を入力します。今回は例として `shell-test` を入力します
- **Board type** ... ボード種別を選択します
- **Location** ... プロジェクトディレクトリを作る一つ上のディレクトリを選択します
- **Stdio support** .. ターミナルにシリアルコンソールを使う場合、Stdio に接続するポート (UART または USB) を選択します。ターミナルに USB キーボードを使う場合は USB のチェックを外してください。
- **Code generation options** ... **`Generate C++ code` にチェックをつけます**

プロジェクトディレクトリと `pico-jxglib` のディレクトリ配置が以下のようになっていると想定します。

```text
+-[pico-jxglib]
+-[shell-test]
  +-CMakeLists.txt
  +-shell-test.cpp
  +- ...
```


以下、このプロジェクトをもとに `CMakeLists.txt` やソースファイルを編集してプログラムを作成していきます。

### シェルの組込み

プログラム中にシェルを組み込むには、以下のコードを記述します。

1. シェルで使用する `Terminal` インスタンス (`Serial::Terminal` または `Display::Terminal`) を生成して初期化
1. 関数 `Shell::AttachTerminal()` で `Terminal` インスタンスをシェルに接続
1. メインループ中で `Tickable::Tick()` を実行

`Terminal` インスタンスの生成方法は、ターミナルに何を使うかによって異なります。以下に具体例を紹介します。

#### ターミナルにシリアルコンソールを使う

Stdio が UART または USB で PC につながっている環境で使用できます。

`CMakeLists.txt` の最後に以下の行を追加します。

```cmake
target_link_libraries(shell-test jxglib_Serial jxglib_Shell jxglib_ShellCmd_Basic)
add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../pico-jxglib pico-jxglib)
```

ソースファイルを以下のように編集します。

```cpp:shell-test.cpp
#include <stdio.h>
#include "pico/stdlib.h"
#include "jxglib/Serial.h"
#include "jxglib/Shell.h"

using namespace jxglib;

int main()
{
    ::stdio_init_all();
    //-------------------------------------------------------------------------
    Serial::Terminal terminal;
    terminal.Initialize();
    Shell::AttachTerminal(terminal);
    terminal.Println("Shell with Serial Terminal");
    //-------------------------------------------------------------------------
    for (;;) {
        // any jobs
        Tickable::Tick();
    }
}
```

#### ターミナルに TFT LCD ST7789 と USB キーボードを使う

Pico ボードに TFT LCD ST7789 と USB キーボードを接続した環境で使用できます。

ブレッドボードの配線イメージは以下の通りです。

![circuit-usbhost-st7789.png](/images/2025-05-08-shell/circuit-usbhost-st7789.png)

`CMakeLists.txt` の最後に以下の行を追加します。また、Stdio の USB 接続が無効になっていること (`pico_enable_stdio_usb(shell-test 0)`) を確認してください。

```cmake
target_link_libraries(shell-test jxglib_USBHost jxglib_ST7789 jxglib_Shell jxglib_ShellCmd_Basic)
add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../pico-jxglib pico-jxglib)
jxglib_configure_USBHost(shell-test CFG_TUH_HID 3)
```

ソースファイルを以下のように編集します。

```cpp:shell-test.cpp
#include <stdio.h>
#include "pico/stdlib.h"
#include "jxglib/ST7789.h"
#include "jxglib/USBHost.h"
#include "jxglib/Shell.h"
#include "jxglib/Font/shinonome16.h"

using namespace jxglib;

int main()
{
    ::stdio_init_all();
    //-------------------------------------------------------------------------
    USBHost::Initialize();
    USBHost::Keyboard keyboard;
    ::spi_init(spi1, 125 * 1000 * 1000);
    GPIO14.set_function_SPI1_SCK();
    GPIO15.set_function_SPI1_TX();
    ST7789 display(spi1, 240, 320, {RST: GPIO10, DC: GPIO11, CS: GPIO12, BL: GPIO13});
    Display::Terminal terminal;
    terminal.Initialize().AttachDisplay(display.Initialize(Display::Dir::Rotate90))
        .AttachKeyboard(keyboard.SetCapsLockAsCtrl()).SetFont(Font::shinonome16);
    Shell::AttachTerminal(terminal);
    terminal.Println("Shell with ST7789 TFT LCD");
    //-------------------------------------------------------------------------
    for (;;) {
        // any jobs
        Tickable::Tick();
    }
}
```

#### ターミナルに OLED SSD1306 と USB キーボードを使う

Pico ボードに OLED SSD1306 と USB キーボードを接続した環境で使用できます。

ブレッドボードの配線イメージは以下の通りです。

![circuit-usbhost-ssd1306.png](/images/2025-05-08-shell/circuit-usbhost-ssd1306.png)

`CMakeLists.txt` の最後に以下の行を追加します。また、Stdio の USB 接続が無効になっていること (`pico_enable_stdio_usb(shell-test 0)`) を確認してください

```cmake
target_link_libraries(shell-test jxglib_USBHost jxglib_SSD1306 jxglib_Shell jxglib_ShellCmd_Basic)
add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../pico-jxglib pico-jxglib)
jxglib_configure_USBHost(shell-test CFG_TUH_HID 3)
```

ソースファイルを以下のように編集します。

```cpp:shell-test.cpp
#include <stdio.h>
#include "pico/stdlib.h"
#include "jxglib/SSD1306.h"
#include "jxglib/USBHost.h"
#include "jxglib/Shell.h"
#include "jxglib/Font/shinonome12.h"

using namespace jxglib;

int main()
{
    ::stdio_init_all();
    //-------------------------------------------------------------------------
    USBHost::Initialize();
    USBHost::Keyboard keyboard;
    ::i2c_init(i2c0, 400 * 1000);
    GPIO4.set_function_I2C0_SDA().pull_up();
    GPIO5.set_function_I2C0_SCL().pull_up();
    SSD1306 display(i2c0, 0x3c);
    Display::Terminal terminal;
    terminal.Initialize().AttachDisplay(display.Initialize())
        .AttachKeyboard(keyboard.SetCapsLockAsCtrl()).SetFont(Font::shinonome12);
    Shell::AttachTerminal(terminal);
    terminal.Println("Shell with SSD1306");
    //-------------------------------------------------------------------------
    for (;;) {
        // any jobs
        Tickable::Tick();
    }
}
```

### シェルコマンドの実行

ライブラリ `jxglib_ShellCmd_Basic` をリンクすると、基本的なシェルコマンドが使えるようになります。

#### `help` コマンド

利用可能なコマンドの一覧を表示します。

```text
>help
about-me        prints information about this own program
about-platform  prints information about the platform
d               prints memory content at the specified address
help            prints help strings for available commands
prompt          changes the command line prompt
ticks           prints names and attributes of running Tickable instances
```

#### `about-platform` コマンド

Pico ボードのプラットフォーム情報を表示します。

```text
>about-platform
RP2350 (ARM) 150 MHz
Flash  0x10000000 - 0x10400000  4194304 bytes
SRAM   0x20000000 - 0x20082000   532480 bytes
```

#### `about-me` コマンド

現在実行しているプログラムの情報を表示します。

```text
shell-test ver.0.1
Flash  0x10000000 - 0x10008488    33928 bytes
Vector 0x20000000 - 0x20000110      272 bytes
Data   0x20000110 - 0x20000BF0     2784 bytes
Bss    0x20000BF0 - 0x200013B4     1988 bytes
Heap   0x200013B4 - 0x20080000   519244 bytes
Stack  0x20080000 - 0x20082000     8192 bytes
```

#### `d` コマンド

メモリのダンプイメージを出力します。引数なしで実行するとアドレス 0x00000000 からのメモリ内容を表示します。

```text
>d
00000000  00 1F 04 20 EB 00 00 00 35 00 00 00 31 00 00 00
00000010  4D 75 01 03 7A 00 C4 00 1D 00 00 00 00 23 02 88
00000020  9A 42 03 D0 43 88 04 30 91 42 F7 D1 18 1C 70 47
00000030  30 BF FD E7 F4 46 00 F0 05 F8 A7 48 00 21 01 60
```

続けて引数なしで実行すると前回の続きのメモリ内容を表示します。

```text
>d
00000040  41 60 E7 46 A5 48 00 21 C9 43 01 60 41 60 70 47
00000050  CA 9B 0D 5B F9 1D 00 00 28 43 29 20 32 30 32 30
00000060  20 52 61 73 70 62 65 72 72 79 20 50 69 20 54 72
00000070  61 64 69 6E 67 20 4C 74 64 00 50 33 09 03 52 33
```

第一引数は先頭アドレス、第二引数は表示バイト数です。16 進数を指定するときは先頭に `0x` をつけます。

```text
>d 0x10000000
10000000  00 B5 32 4B 21 20 58 60 98 68 02 21 88 43 98 60
10000010  D8 60 18 61 58 61 2E 4B 00 21 99 60 02 21 59 61
10000020  01 21 F0 22 99 50 2B 49 19 60 01 21 99 60 35 20
10000030  00 F0 44 F8 02 22 90 42 14 D0 06 21 19 66 00 F0
```

```text
>d 0x10000000 256
10000000  00 B5 32 4B 21 20 58 60 98 68 02 21 88 43 98 60
10000010  D8 60 18 61 58 61 2E 4B 00 21 99 60 02 21 59 61
10000020  01 21 F0 22 99 50 2B 49 19 60 01 21 99 60 35 20
10000030  00 F0 44 F8 02 22 90 42 14 D0 06 21 19 66 00 F0
10000040  34 F8 19 6E 01 21 19 66 00 20 18 66 1A 66 00 F0
10000050  2C F8 19 6E 19 6E 19 6E 05 20 00 F0 2F F8 01 21
10000060  08 42 F9 D1 00 21 99 60 1B 49 19 60 00 21 59 60
10000070  1A 49 1B 48 01 60 01 21 99 60 EB 21 19 66 A0 21
10000080  19 66 00 F0 12 F8 00 21 99 60 16 49 14 48 01 60
10000090  01 21 99 60 01 BC 00 28 00 D0 00 47 12 48 13 49
100000A0  08 60 03 C8 80 F3 08 88 08 47 03 B5 99 6A 04 20
100000B0  01 42 FB D0 01 20 01 42 F8 D1 03 BD 02 B5 18 66
100000C0  18 66 FF F7 F2 FF 18 6E 18 6E 02 BD 00 00 02 40
100000D0  00 00 00 18 00 00 07 00 00 03 5F 00 21 22 00 00
100000E0  F4 00 00 18 22 20 00 A0 00 01 00 10 08 ED 00 E0
100000F0  00 00 00 00 00 00 00 00 00 00 00 00 74 B2 4E 7A
```

### シェルコマンドの作成

シェルコマンドを作成するには `ShellCmd` マクロを使います。マクロのフォーマットは以下の通りです。

```cpp
ShellCmd(name, "comment")
{
    // any code
    return 0;
}
```

コマンドプログラムには以下の変数が渡されます。

- `Terminal& terminal` ... `Terminal` インスタンス。
- `int argc` ... 引数の数
- `char** argv` ... 引数文字列。`argv[0]` はコマンド自身の名前が格納されます

戻り値は、エラーがない場合 `0`、エラーが発生した場合は `1` を返してください。

コマンドを登録する手順などは**必要ありません**。`ShellCmd` マクロでコマンドを作成すると、自動的にシェルに登録されます。この仕組みにより、コマンドを実装したソースファイルをメインのプログラムにリンクするだけでコマンドの追加ができるようになります。

以下は、渡された引数の内容を表示するサンプルプログラムです。このコードを上記の `shell-test.cpp` 中に追加するか、独立したソースファイルに記述して `add_executable()` などにそのソースファイルを追加すると、コマンドとして利用できるようになります。

```cpp
ShellCmd(argtest, "tests command line arguments")
{
    for (int i = 0; i < argc; i++) {
        terminal.Printf("argv[%d] \"%s\"\n", i, argv[i]);
    }
    return 0;
}
```
