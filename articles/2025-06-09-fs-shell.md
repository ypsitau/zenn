---
title: "pico-jxglib のシェルでファイルシステムを操作する話 (自動補完で入力楽々)"
emoji: "🎉"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["組み込み", "raspberrypi", "pico", "raspberrypipico", "shell"]
published: false
---
**pico-jxglib** は、ワンボードマイコン Raspberry Pi Pico の Pico SDK プログラミングをサポートするライブラリです。

https://zenn.dev/ypsitau/articles/2025-01-24-jxglib-intro

今回は、[pico-jxglib のシェル](https://zenn.dev/ypsitau/articles/2025-05-08-shell) でファイルシステムを操作する方法について解説します。自動補完機能やリダイレクト機能を使って、コマンドラインからファイルやディレクトリを簡単に操作できるようになります。

## ファイルシステムとシェル

以下の記事で、ファイルシステムの基本的な使い方を紹介しました。

▶️ [pico-jxglib で Pico ボードにファイルシステムを実装してフラッシュメモリをフル活用する話](https://zenn.dev/ypsitau/articles/2025-05-31-fs-flash)
▶️ [pico-jxglib で Pico ボードに SD カードや USB ストレージを接続する話](https://zenn.dev/ypsitau/articles/2025-06-06-fs-media)

ファイルシステムをプログラムに組み込むという観点からするとこれらの内容で十分なのですが、ファイルやディレクトリを操作するためにいちいちプログラムを書いてビルドして書き込むのは面倒です。そこで、**pico-jxglib** のシェルにファイルシステムを操作するためのコマンドを追加してより便利に扱えるようにしました。

シェルのキーボード操作方法については[こちら](https://zenn.dev/ypsitau/articles/2025-04-06-cmdline-editor#%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%83%A9%E3%82%A4%E3%83%B3%E7%B7%A8%E9%9B%86%E6%A9%9F%E8%83%BD%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6)を参照ください。

ファイル操作に便利な以下の機能を追加しています。

- **自動補完機能**
  Tab キーでコマンド名やファイル名を自動的に補完します。ヒストリ機能もあわせて使うことでコマンドの入力が非常に楽になります

- **リダイレクト機能**
  シェルコマンドの出力をファイルに保存することができます

組み込みシステムにシェルを組み込むというと、シェルを動かしている間はほかの処理が停止したり負荷がかかりそうに思えますが、**pico-jxglib** のシェルはバックグラウンドで動作して、本来の機能に影響を与えないように設計されています。組み込みや取り外しも簡単にできますから、必要なときだけシェルを有効にして使うこともできます。Pico ボードに USB キーボードと TFT LCD を接続し、それらを使ってシェルを操作することもできます。詳細は[「pico-jxglib で Pico ボードにシェルを実装する話」](https://zenn.dev/ypsitau/articles/2025-05-08-shell) をご覧ください。

## 実際のプロジェクト

### システム構成

本記事はシェルを使ったファイルシステムの操作方法を紹介するのが目的なので、Pico ボード単体で動作して Flash メモリ上にファイルシステムを展開するシステム構成にします。シェルの操作は UART または USB で接続したホスト PC のターミナルソフトから行います。

### 開発環境のセットアップ

Visual Studio Code や Git ツール、Pico SDK のセットアップが済んでいない方は[「Pico SDK ことはじめ」](https://zenn.dev/ypsitau/articles/2025-01-17-picosdk#%E9%96%8B%E7%99%BA%E7%92%B0%E5%A2%83) をご覧ください。

GitHub から **pico-jxglib** をクローンします。

```bash
git clone https://github.com/ypsitau/pico-jxglib.git
cd pico-jxglib
git submodule update --init
```

:::message
**pico-jxglib** はほぼ毎日更新されています。すでにクローンしている場合は、`pico-jxglib` ディレクトリで以下のコマンドを実行して最新のものにしてください。

```bash
git pull
```

:::

### プロジェクトの作成

VSCode のコマンドパレットから `>Raspberry Pi Pico: New Pico Project` を実行し、以下の内容でプロジェクトを作成します。Pico SDK プロジェクト作成の詳細や、ビルド、ボードへの書き込み方法については[「Pico SDK ことはじめ」](https://zenn.dev/ypsitau/articles/2025-01-17-picosdk#%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90%E3%81%A8%E7%B7%A8%E9%9B%86) を参照ください。

- **Name** ... プロジェクト名を入力します。今回は例として `fs-shell` を入力します
- **Board type** ... ボード種別を選択します
- **Location** ... プロジェクトディレクトリを作る一つ上のディレクトリを選択します
- **Stdio support** .. ターミナルソフトに接続するポート (UART または USB) を選択します
- **Code generation options** ... **`Generate C++ code` にチェックをつけます**

プロジェクトディレクトリと `pico-jxglib` のディレクトリ配置が以下のようになっていると想定します。

```text
├── pico-jxglib/
└── fs-shell/
    ├── CMakeLists.txt
    ├── fs-shell.cpp
    └── ...
```

以下、このプロジェクトをもとに `CMakeLists.txt` やソースファイルを編集してプログラムを作成していきます。

### シェルとファイルシステム操作コマンドの組込み

シェルとファイルシステムコマンドを組み込むには、`CMakeLists.txt` の最後に以下の行を追加します。

```cmake
target_link_libraries(fs-shell jxglib_LFS_Flash jxglib_Serial jxglib_ShellCmd_FS)
add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/../pico-jxglib pico-jxglib)
```

ソースファイルを以下のように編集します。

```cpp
#include <stdio.h>
#include "pico/stdlib.h"
#include "jxglib/Serial.h"
#include "jxglib/Shell.h"
#include "jxglib/LFS/Flash.h"
#include "jxglib/FAT/Flash.h"

using namespace jxglib;

int main()
{
    ::stdio_init_all();
    LFS::Flash driveA("A:", 0x1010'0000, 0x0004'0000);  // Flash address and size 256kB
    LFS::Flash driveB("B:", 0x1014'0000, 0x0004'0000);  // Flash address and size 256kB
    LFS::Flash driveC("*C:", 0x1018'0000, 0x0004'0000); // Flash address and size 256kB
    FAT::Flash driveD("D:", 0x101c'0000, 0x0004'0000);  // Flash address and size 256kB
    Serial::Terminal terminal;
    Shell::AttachTerminal(terminal.Initialize());
    for (;;) {
        // :
        // any other jobs
        // :
        Tickable::Tick();
    }
}
```

このコードでは、Flash メモリ上に 3 つの LittleFS ファイルシステムと一つの FAT ファイルシステムを作成します。ドライブ名に `*` をつけたドライブはプライマリドライブとして扱われ、シェルのカレントドライブになります。

`Shell::Terminal` のインスタンスを生成して `Shell::AttachTerminal()` 関数でシェルに接続すると、シェルがメインループ中で動作するようになります。

シェルにファイルシステム操作コマンドを追加するのに必要なのは `jxglib_ShellCmd_FS` ライブラリをリンクすることだけです。ソースファイルの編集は必要ありません。

## シェルによるファイル操作

作成したプログラムを使って、シェルを使ったファイル操作の実例を紹介します。`Tab` キーで補完機能が働くので、コマンド入力やファイル選択が楽になります。

プログラムを実行すると、以下のプロンプトが表示されます。

```bash
C:?>
```

プロンプトには、カレントドライブとカレントディレクトリが含まれています。`C:` ドライブはまだフォーマットされていないので、カレントディレクトリは `?` になっています。

シェルコマンド `ls-drive` でドライブの一覧を表示できます。

```bash
C:?>ls-drive
 Drive  Format           Total
 A:     unmounted            0
 B:     unmounted            0
*C:     unmounted            0
 D:     unmounted            0
```

どのドライブもフォーマットされていないので、unmounted になっています。

シェルコマンド `format` で指定したドライブをフォーマットします。複数のドライブを同時にフォーマットすることもできます。

```bash
C:?>format a: b: c: d:
drive a: formatted in LittleFS
drive b: formatted in LittleFS
drive c: formatted in LittleFS
drive d: formatted in FAT12
```

フォーマットが完了すると、プロンプトが以下のように変わります。

```bash
C:/>
```

シェルコマンド `ls-drive` でドライブの状態を確認します。

```bash
C:/>ls-drive
 Drive  Format          Total
 A:     LittleFS       262144
 B:     LittleFS       262144
*C:     LittleFS       262144
 D:     FAT12          262144
```

これで、ドライブがフォーマットされて使用可能になりました。以下、このファイルシステムを使ってファイルやディレクトリを操作していきます。Pico ボードのフラッシュメモリ上に構築されたファイルシステムなので、どんな操作をしても大丈夫です。すべてをもとに戻したいときは `format` コマンドを実行してください。

`mkdir` コマンドでディレクトリを作成します。`ls` コマンドでディレクトリの一覧を表示します。

```bash
C:/>mkdir dir1 dir2 dir3
C:/>ls
d---- 2000-01-01 00:00:00        dir1/
d---- 2000-01-01 00:00:00        dir2/
d---- 2000-01-01 00:00:00        dir3/
```

`cd` コマンドで `dir1` に移ってサブディレクトリを作成します。

```bash
C:/>cd dir1
C:/dir1>mkdir dir1-1 dir1-2
```

`touch` コマンドで中身のないファイルを作成します。

```bash
C:/dir1>touch file1-1.txt file1-2.txt
C:/dir1>cd..
C:/>
```

ドライブ名のみを入力すると、カレントドライブを切り替えることができます。

```bash
C:/>a:
A:/>c:
C:/>
```

キーボードで入力した内容をファイルに保存するには、`cat` コマンドを引数なしで実行します。`cat > filename` と入力して `Enter` キーを押すと、キーボードからの入力が始まります。入力が終わったら `Ctrl-C` を押して終了します。

```bash
C:/>cd dir2
C:/dir2>cat > file2-1.txt
This is the first file.
^C
C:/dir2>cat > file2-2.txt
This is the second file.
^C
```

`cat` コマンドでファイルの内容を結合します。

```bash
C:/dir2>cat file2-1.txt file2-2.txt > file2-3.txt
C:/dir2>cat text2-3.txt
This is the first file.
This is the second file.
```

`ls` コマンドは `--sort` オプションで名前、日付、サイズでソートできます。

```bash
C:/dir2>ls --sort=time

```


`d` コマンドはメモリダンプを標準出力に表示します。リダイレクト機能を使って、標準出力をファイルに保存することができます。リダイレクトで `>>` を使うと、ファイルの末尾に追記されます。

```bash
C:/dir2>cd /dir3
C:/dir3>d > file3-1.txt
C:/dir3>d > file3-2.txt
C:/dir3>d >> file3-3.txt
C:/dir3>ls
-a--- 1970-01-01 00:00:00    208 file3-1.txt
-a--- 1970-01-01 00:00:00    416 file3-2.txt
C:/dir3>cat file3-1.txt
00  00 1F 04 20 EB 00 00 00 35 00 00 00 31 00 00 00
10  4D 75 01 03 7A 00 C4 00 1D 00 00 00 00 23 02 88
20  9A 42 03 D0 43 88 04 30 91 42 F7 D1 18 1C 70 47
30  30 BF FD E7 F4 46 00 F0 05 F8 A7 48 00 21 01 60
C:/dir3>cat file3-2.txt
40  41 60 E7 46 A5 48 00 21 C9 43 01 60 41 60 70 47
50  CA 9B 0D 5B F9 1D 00 00 28 43 29 20 32 30 32 30
60  20 52 61 73 70 62 65 72 72 79 20 50 69 20 54 72
70  61 64 69 6E 67 20 4C 74 64 00 50 33 09 03 52 33
80  2D 03 4C 33 57 03 54 33 8F 03 4D 53 B9 26 53 34
90  AD 26 4D 43 1D 26 43 34 05 26 55 42 91 25 44 54
A0  A9 01 44 45 AF 01 57 56 45 01 49 46 91 24 45 58
B0  E5 23 52 45 6D 23 52 50 B5 23 46 43 51 23 43 58
```

`cp` コピーでファイルをコピーします。`cp -r` オプションを使うと、ディレクトリごとコピーできます。

```bash
C:/dir3>cd /
C:/>cp dir1/file1-1.txt .
C:/>ls
C:/>cp -r dir1 dir4
```

```bash
C:/>cp -r dir1 dir2 dir3 a:
C:/>ls a:
d---- 2000-01-01 00:00:00        dir1/
d---- 2000-01-01 00:00:00        dir2/
d---- 2000-01-01 00:00:00        dir3/
C:/>cp -r * b:
C:/>ls a:
d---- 2000-01-01 00:00:00        dir1/
d---- 2000-01-01 00:00:00        dir2/
d---- 2000-01-01 00:00:00        dir3/
```






シェルコマンド `mv` でファイルを移動します。複数のファイルを指定でき、ワイルドカードも使用できます。`mv` コマンドは、ファイルの名前を変更することもできます。

```bash
C:/>mv dir1/file1.txt dir2
C:/>ls dir2
```

シェルコマンド `rm` でファイルやディレクトリを削除します。複数のファイルを指定でき、ワイルドカードも使用できます。`rm -r` オプションを使うと、ディレクトリごと削除できます。

```bash
C:/>ls
d---- 2000-01-01 00:00:00        dir1/
d---- 2000-01-01 00:00:00        dir2/
d---- 2000-01-01 00:00:00        dir3/
-a--- 2000-01-01 00:00:00      0 file1.txt
-a--- 2000-01-01 00:00:00      0 file2.txt
-a--- 2000-01-01 00:00:00      0 file3.txt
C:/>rm file3.txt
C:/>rm *.txt
C:/>ls
d---- 2000-01-01 00:00:00        dir1/
d---- 2000-01-01 00:00:00        dir2/
d---- 2000-01-01 00:00:00        dir3/
C:/>rm -r dir1.txt
C:/>ls
d---- 2000-01-01 00:00:00        dir2/
d---- 2000-01-01 00:00:00        dir3/
C:/>rm -r *
C:/>ls
```

シェルコマンド `tree` でディレクトリの階層構造をツリー形式で表示します。

```bash
C:/>tree
.
├── dir1
│   ├── subdir1
│   ├── subdir2
│   ├── subfile1
│   └── subfile2
├── dir2
│   ├── text1.txt
│   ├── text2.txt
│   └── text3.txt
├── dir3
│   ├── dump1.txt
│   └── dump2.txt
├── file1.txt
├── file2.txt
└── file3.txt
```
